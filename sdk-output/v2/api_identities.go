/*
SailPoint SaaS API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sailpointv2sdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// IdentitiesApiService IdentitiesApi service
type IdentitiesApiService service

type ApiCreateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	sourceId *string
	dynamicSchemaEto *DynamicSchemaEto
}

// ID of a flat-file source into which the new account will be created.
func (r ApiCreateIdentityRequest) SourceId(sourceId string) ApiCreateIdentityRequest {
	r.sourceId = &sourceId
	return r
}

// Attribute values for the new identity. The schema and required attributes are dictated by the source.
func (r ApiCreateIdentityRequest) DynamicSchemaEto(dynamicSchemaEto DynamicSchemaEto) ApiCreateIdentityRequest {
	r.dynamicSchemaEto = &dynamicSchemaEto
	return r
}

func (r ApiCreateIdentityRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateIdentityExecute(r)
}

/*
CreateIdentity Creates a new identity.

Creates a new identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIdentityRequest
*/
func (a *IdentitiesApiService) CreateIdentity(ctx context.Context) ApiCreateIdentityRequest {
	return ApiCreateIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentitiesApiService) CreateIdentityExecute(r ApiCreateIdentityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.CreateIdentity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceId == nil {
		return nil, reportError("sourceId is required and must be specified")
	}
	if r.dynamicSchemaEto == nil {
		return nil, reportError("dynamicSchemaEto is required and must be specified")
	}

	localVarQueryParams.Add("sourceId", parameterToString(*r.sourceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dynamicSchemaEto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateLauncherRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	appId *string
	accessProfileId string
	context *string
}

// ID of the app to create a launcher for.
func (r ApiCreateLauncherRequest) AppId(appId string) ApiCreateLauncherRequest {
	r.appId = &appId
	return r
}

// Context of launcher links to include. Specifying a mobile context will provide links to mobile resources for the launcher if available.
func (r ApiCreateLauncherRequest) Context(context string) ApiCreateLauncherRequest {
	r.context = &context
	return r
}

func (r ApiCreateLauncherRequest) Execute() (*Launcher, *http.Response, error) {
	return r.ApiService.CreateLauncherExecute(r)
}

/*
CreateLauncher Creates a new launcher.

Creates a new launcher for the given identity. This endpoint is found in links within the 'accessMethods' attribute for GET identities/{id}/apps response body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @param accessProfileId ID of an access profile.
 @return ApiCreateLauncherRequest
*/
func (a *IdentitiesApiService) CreateLauncher(ctx context.Context, identityIdOrAlias string, accessProfileId string) ApiCreateLauncherRequest {
	return ApiCreateLauncherRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
		accessProfileId: accessProfileId,
	}
}

// Execute executes the request
//  @return Launcher
func (a *IdentitiesApiService) CreateLauncherExecute(r ApiCreateLauncherRequest) (*Launcher, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Launcher
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.CreateLauncher")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}/launchers"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessProfileId"+"}", url.PathEscape(parameterToString(r.accessProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}

	localVarQueryParams.Add("appId", parameterToString(*r.appId, ""))
	if r.context != nil {
		localVarQueryParams.Add("context", parameterToString(*r.context, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIdentityRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
}

func (r ApiDeleteIdentityRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIdentityExecute(r)
}

/*
DeleteIdentity Deletes an identity.

Deletes an existing identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiDeleteIdentityRequest
*/
func (a *IdentitiesApiService) DeleteIdentity(ctx context.Context, identityIdOrAlias string) ApiDeleteIdentityRequest {
	return ApiDeleteIdentityRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
func (a *IdentitiesApiService) DeleteIdentityExecute(r ApiDeleteIdentityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.DeleteIdentity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ExceptionObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLauncherRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	launcherId string
}

func (r ApiDeleteLauncherRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLauncherExecute(r)
}

/*
DeleteLauncher Deletes a launcher.

Deletes an existing launcher for the given identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @param launcherId ID of a launcher.
 @return ApiDeleteLauncherRequest
*/
func (a *IdentitiesApiService) DeleteLauncher(ctx context.Context, identityIdOrAlias string, launcherId string) ApiDeleteLauncherRequest {
	return ApiDeleteLauncherRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
		launcherId: launcherId,
	}
}

// Execute executes the request
func (a *IdentitiesApiService) DeleteLauncherExecute(r ApiDeleteLauncherRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.DeleteLauncher")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}/launchers/{launcherId}"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"launcherId"+"}", url.PathEscape(parameterToString(r.launcherId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIdentityRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
}

func (r ApiGetIdentityRequest) Execute() (*IdentityV2, *http.Response, error) {
	return r.ApiService.GetIdentityExecute(r)
}

/*
GetIdentity Retrieves the identity by ID or alias.

Retrieves the identity by ID or alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiGetIdentityRequest
*/
func (a *IdentitiesApiService) GetIdentity(ctx context.Context, identityIdOrAlias string) ApiGetIdentityRequest {
	return ApiGetIdentityRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
//  @return IdentityV2
func (a *IdentitiesApiService) GetIdentityExecute(r ApiGetIdentityRequest) (*IdentityV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.GetIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApprovalsRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	sort *string
	offset *int32
	limit *int32
}

// One or more attributes on which to sort, each separated by a &#39;,&#39;. Prefix with a minus sign (ex. -dateCreated) for descending sort.
func (r ApiListApprovalsRequest) Sort(sort string) ApiListApprovalsRequest {
	r.sort = &sort
	return r
}

// Paging offset.
func (r ApiListApprovalsRequest) Offset(offset int32) ApiListApprovalsRequest {
	r.offset = &offset
	return r
}

// Paging limit.
func (r ApiListApprovalsRequest) Limit(limit int32) ApiListApprovalsRequest {
	r.limit = &limit
	return r
}

func (r ApiListApprovalsRequest) Execute() ([]Approval, *http.Response, error) {
	return r.ApiService.ListApprovalsExecute(r)
}

/*
ListApprovals Lists the approvals.

Lists access request approvals owned by the given identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiListApprovalsRequest
*/
func (a *IdentitiesApiService) ListApprovals(ctx context.Context, identityIdOrAlias string) ApiListApprovalsRequest {
	return ApiListApprovalsRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
//  @return []Approval
func (a *IdentitiesApiService) ListApprovalsExecute(r ApiListApprovalsRequest) ([]Approval, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Approval
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.ListApprovals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}/approvals"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppsRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	filters *string
	sort *string
	offset *int32
	limit *int32
}

// Search filters. Supported operator is &#39;EQ&#39;. Supported attribute for filtering is ‘description’. Example: &#39;description EQ \&quot;Some description.\&quot;&#39;.
func (r ApiListAppsRequest) Filters(filters string) ApiListAppsRequest {
	r.filters = &filters
	return r
}

// One or more attributes on which to sort, each separated by a &#39;,&#39;. Prefix with a minus sign (ex. -dateCreated) for descending sort.
func (r ApiListAppsRequest) Sort(sort string) ApiListAppsRequest {
	r.sort = &sort
	return r
}

// Paging offset.
func (r ApiListAppsRequest) Offset(offset int32) ApiListAppsRequest {
	r.offset = &offset
	return r
}

// Paging limit.
func (r ApiListAppsRequest) Limit(limit int32) ApiListAppsRequest {
	r.limit = &limit
	return r
}

func (r ApiListAppsRequest) Execute() ([]App, *http.Response, error) {
	return r.ApiService.ListAppsExecute(r)
}

/*
ListApps Lists available apps.

Lists all apps available to the given identity. The list will include apps which have launchers created for the identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiListAppsRequest
*/
func (a *IdentitiesApiService) ListApps(ctx context.Context, identityIdOrAlias string) ApiListAppsRequest {
	return ApiListAppsRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
//  @return []App
func (a *IdentitiesApiService) ListAppsExecute(r ApiListAppsRequest) ([]App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.ListApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		localVarQueryParams.Add("filters", parameterToString(*r.filters, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIdentitiesRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	filters *string
	sort *string
	offset *int32
	limit *int32
}

// Search filters. Supported operator is &#39;EQ&#39;. Supported attribute for filtering is ‘permissions’. Example: &#39;permissions EQ \&quot;admin\&quot;&#39;.
func (r ApiListIdentitiesRequest) Filters(filters string) ApiListIdentitiesRequest {
	r.filters = &filters
	return r
}

// One or more attributes on which to sort, each separated by a &#39;,&#39;. Prefix with a minus sign (ex. -dateCreated) for descending sort.
func (r ApiListIdentitiesRequest) Sort(sort string) ApiListIdentitiesRequest {
	r.sort = &sort
	return r
}

// Paging offset.
func (r ApiListIdentitiesRequest) Offset(offset int32) ApiListIdentitiesRequest {
	r.offset = &offset
	return r
}

// Paging limit.
func (r ApiListIdentitiesRequest) Limit(limit int32) ApiListIdentitiesRequest {
	r.limit = &limit
	return r
}

func (r ApiListIdentitiesRequest) Execute() ([]IdentityV2, *http.Response, error) {
	return r.ApiService.ListIdentitiesExecute(r)
}

/*
ListIdentities Retrieves the identities.

Retrieves the identities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdentitiesRequest
*/
func (a *IdentitiesApiService) ListIdentities(ctx context.Context) ApiListIdentitiesRequest {
	return ApiListIdentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IdentityV2
func (a *IdentitiesApiService) ListIdentitiesExecute(r ApiListIdentitiesRequest) ([]IdentityV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IdentityV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.ListIdentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		localVarQueryParams.Add("filters", parameterToString(*r.filters, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLaunchersRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	context *string
	sort *string
}

// Context of launcher links to include. Specifying a mobile context will provide links to mobile resources for the launcher if available.
func (r ApiListLaunchersRequest) Context(context string) ApiListLaunchersRequest {
	r.context = &context
	return r
}

// One or more attributes on which to sort, each separated by a &#39;,&#39;. Prefix with a minus sign (ex. -dateCreated) for descending sort.
func (r ApiListLaunchersRequest) Sort(sort string) ApiListLaunchersRequest {
	r.sort = &sort
	return r
}

func (r ApiListLaunchersRequest) Execute() ([]Launcher, *http.Response, error) {
	return r.ApiService.ListLaunchersExecute(r)
}

/*
ListLaunchers Lists the launchers.

Lists the launchers for the given identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiListLaunchersRequest
*/
func (a *IdentitiesApiService) ListLaunchers(ctx context.Context, identityIdOrAlias string) ApiListLaunchersRequest {
	return ApiListLaunchersRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
//  @return []Launcher
func (a *IdentitiesApiService) ListLaunchersExecute(r ApiListLaunchersRequest) ([]Launcher, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Launcher
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.ListLaunchers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}/launchers"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.context != nil {
		localVarQueryParams.Add("context", parameterToString(*r.context, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockIdentitiesRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	requestBody *[]string
}

// Array of one or more IDs.
func (r ApiLockIdentitiesRequest) RequestBody(requestBody []string) ApiLockIdentitiesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiLockIdentitiesRequest) Execute() (*MultiStatusObject, *http.Response, error) {
	return r.ApiService.LockIdentitiesExecute(r)
}

/*
LockIdentities Locks one or more identities.

Locks one or more identities. Identities MUST reset their password in order to be unlocked.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLockIdentitiesRequest
*/
func (a *IdentitiesApiService) LockIdentities(ctx context.Context) ApiLockIdentitiesRequest {
	return ApiLockIdentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiStatusObject
func (a *IdentitiesApiService) LockIdentitiesExecute(r ApiLockIdentitiesRequest) (*MultiStatusObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiStatusObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.LockIdentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/bulk-lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentitiesApiService
	identityIdOrAlias string
	identityEto *IdentityEto
}

// Identity attributes to update.
func (r ApiUpdateIdentityRequest) IdentityEto(identityEto IdentityEto) ApiUpdateIdentityRequest {
	r.identityEto = &identityEto
	return r
}

func (r ApiUpdateIdentityRequest) Execute() (*IdentityV2, *http.Response, error) {
	return r.ApiService.UpdateIdentityExecute(r)
}

/*
UpdateIdentity Updates one or more identity attributes.

Updates one or more attributes of an identity, found by ID or alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identityIdOrAlias ID or alias of an identity.
 @return ApiUpdateIdentityRequest
*/
func (a *IdentitiesApiService) UpdateIdentity(ctx context.Context, identityIdOrAlias string) ApiUpdateIdentityRequest {
	return ApiUpdateIdentityRequest{
		ApiService: a,
		ctx: ctx,
		identityIdOrAlias: identityIdOrAlias,
	}
}

// Execute executes the request
//  @return IdentityV2
func (a *IdentitiesApiService) UpdateIdentityExecute(r ApiUpdateIdentityRequest) (*IdentityV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentitiesApiService.UpdateIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identities/{identityIdOrAlias}"
	localVarPath = strings.Replace(localVarPath, "{"+"identityIdOrAlias"+"}", url.PathEscape(parameterToString(r.identityIdOrAlias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identityEto == nil {
		return localVarReturnValue, nil, reportError("identityEto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identityEto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
